
平均CPU的使用率=1-（空闲时间new-空闲时间old）/（总CPU时间new-总CPU时间Old）

 /proc/stat 提供的就 是系统的 CPU 和任务统计信息.
 
 /proc/[pid]/stat可以查看每个进程的运行情况。
 
 perf 是 Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性 能，还可以用来分析指定应用程序的性能问题。
 
 当系统CPU使用率升高，但又没有办法通过top等命令查看到是哪一个进程升高的时候，这时CPU的使用率就不太正常，一般情况下导致这种情况的原因是短时应用所导致。
 1. 应用中调用了外部的大量二进制程序，这些程序的运行时间又比较短，因此不容易被top命令查看出来。
 2. 程序因为某种原因不短的崩溃重启，而启动过程中资源初始化，很可能会占用相当多的CPU。
 
 ##### 排查的办法：
**1.使用per工具**

 ```
  记录性能事件，等待大约15秒后按 Ctrl+C 退出
  $ perf record -g
  查看报告
  $ perf report
```
**2. execsnoop工具**

execsnoop 就是一个专为短时进程设计的工具。它通过 ftrace 实时监控进程的 exec() 行为，并输出短时进程的基本信息，包括进程PID、父进程 PID、命令行参数以及执行的结果。

#### IO等待CPU的使用率升高，既iowait升高怎么办？

1. 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
2. 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程

1. 僵尸进程持续的时间都比较短，在父进程回收它的资源后就会消亡;或者在父进程退出 后，由 init 进程回收后也会消亡。
2. 一旦父进程没有处理子进程的终止，还一直保持运行状态，那么子进程就会一直处于僵尸状态。 大量的僵尸进程会用尽 PID 进程号，导致新进程不能创建
 
 使用top命令打印出的信息中，`S`栏表示进程status状态，以下是进程的几种状态：
- R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待 运行。
- D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠(Uninterruptible Sleep)，一般表示进程 正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。
- Z 是 Zombie 的缩写，如果你玩过“植物大战僵尸”这款游戏，应该知道它的意思。它表示僵尸 进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源(比如进程的描述 符、PID 等)。
- S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系 统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。
- I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导 致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载， 用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程 却不会。
- T 或者 t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。向一个进程发送 SIGSTOP信号，它就会因响应这个信号变成暂停状态(Stopped);再向它发 送 SIGCONT 信号，进程又会恢复运行(如果进程是终端里直接启动的，则需要你用 fg 命令， 恢复到前台运行)。
- X，也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps命令中看到它。

当使用ps等工具查看进程的使用状况的时候，如果状态是Ss+或者D+，其中，S表示可中断睡眠状态，D表示不可中断睡眠状态，s表示这一个进程是会话领导进程，+表示领导进程。

- 会话：指共享同一个终端的一个或者多个进程组。
- 进程组表示一组相互关联的进程，比如父进程的所有子进程就是一个进程组。

比如，我们通过 SSH 登录服务器，就会打开一个控制终端(TTY)，这个控制终端就对应一个 会话。而我们在终端中运行的命令以及它们的子进程，就构成了一个个的进程组，其中，在后台 运行的命令，构成后台进程组;在前台运行的命令，构成前台进程组。

![top](https://github.com/ljcan/jqBlogs/blob/master/Linux/top%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E6%A0%BC%E5%BC%8F%E4%B8%8A%E5%8D%8810.27.53.png)

- 先看第一行的平均负载( Load Average)，过去1 分钟、5 分钟和 15 分钟内的平均负载在依 次减小，说明平均负载正在升高;而 1 分钟内的平均负载已经达到系统的 CPU 个数，说明系 统很可能已经有了性能瓶颈。
- 再看第二行的 Tasks，有 1 个正在运行的进程，但僵尸进程比较多，而且还在不停增加，说 明有子进程在退出时没被清理。
- 接下来看两个 CPU 的使用率情况，用户 CPU 和系统 CPU 都不高，但 iowait 分别是 60.5% 和 94.6%，好像有点儿不正常。
- 最后再看每个进程的情况， CPU 使用率最高的进程只有 0.3%，看起来并不高;但有两个进 程处于 D 状态，它们可能在等待 I/O，但光凭这里并不能确定是它们导致了iowait 升高。

**dstat工具**

可以同时查看 CPU 和 I/O 这两种 资源的使用情况，便于对比分析。

strace 正是最常用的跟踪进程系统调用的工具。所以，我们从 pidstat 的输出中拿到进程的 PID 号，比如 6082，然后在终端中运行 strace 命令，并用 -p 参数指定 PID 号:
```
strace -p 6082
strace: attach: ptrace(PTRACE_SEIZE, 6082): Operation not permitted
```

1. 虽然这个案例是磁盘 I/O 导致了 iowait 升高，不过， iowait 高不一定代表I/O 有性能瓶颈。当 系统中只有 I/O 类型的进程在运行时，iowait 也会很高，但实际上，磁盘的读写远没有达 到性能瓶颈的程度。
2. 因此，碰到 iowait 升高时，需要先用 dstat、pidstat 等工具，确认是不是磁盘 I/O 的问题，然后 再找是哪些进程导致了 I/O。
3. 等待 I/O 的进程一般是不可中断状态，所以用 ps 命令找到的 D 状态(即不可中断状态)的进 程，多为可疑进程。但这个案例中，在 I/O 操作后，进程又变成了僵尸进程，所以不能用 strace 直接分析这个进程的系统调用。
4. 这种情况下，我们用了 perf 工具，来分析系统的 CPU 时钟事件，最终发现是直接 I/O 导致的问题。这时，再检查源码中对应位置的问题，就很轻松了。 而僵尸进程的问题相对容易排查，使用 pstree 找出父进程后，去查看父进程的代码，检查 wait()
/ waitpid() 的调用，或是 SIGCHLD 信号处理函数的注册就行了。

```
# 先停止产生僵尸进程的 app
$ docker rm -f app
# 然后启动新的 app
$ docker run --privileged --name=app -itd feisky/app:iowait-fix2
```


 
 
 
