缓存与数据库更新操作会引发一系列的问题，先写数据库，还是先更新缓存（删除缓存）。

一般情况下，我们先写数据库，然后删除缓存，并且必须保证这两个操作是原子操作。

如果是先删除缓存，然后写数据库，那么可能会导致数据不一致性问题，比如事务A先删除缓存时，还没写入数据库，这时另一个请求B过来，缓存中没有，
直接去数据库中读取数据，这时A写入数据库，那么B返回的就是旧的数据，导致了数据不一致。

**如何解决这些问题呢？**

常用的有三种方法：
1. 读写队列串行更新策略。
2. 延时双删策略。
3. 异步更新缓存策略（基于binlog日志）。

**1.读写队列串行更新策略**

这种方法就是将读写请求通过hash的方式分发到不同的队列中，对于同一数据的读写请求放到同一队列中，这样写请求完成了
写入操作，读请求会读取到最新的数据，这样的更新方式其实就是将读写请求串行化的方式。需要注意的是读请求可能会等待时间过长，
我们只需要将对于同一数据的读请求其中的一个放入队列中，其他的挡在cache层，这样一个读请求获取数据，更新cache，这样其他请求也可以
读取到最新的数据，并且加入超时机制，当读请求在一定时间内没有响应，直接去DB中读取数据。

**2.延时双删策略**

先删除缓存，然后更新数据库；休眠一段时间；再次删除缓存。

这样可能会导致的问题是：1.性能受到影响，如果是热点数据，那么在休眠的这一段时间可能大量请求直连DB，导致性能下降。
2.当再次删除缓存的时候，如果删除失败，一样会影响业务，导致数据不一致性问题。

**3.异步更新缓存策略**

写流程：
1. 先删除缓存，再写入数据库。
2. 使用额外的组件同步写操作binlog日志到消息队列。
3. 缓存从消息队列中消费数据，更新缓存。

读流程：
1. 先从缓存中获取。
2. 缓存中获取不到，从DB中获取，并且将数据发送到消息队列。
3. 消息队列更新缓存中的数据。

该策略通过并行化的方式引入解决了以上问题，但是带来的问题是主库和缓存延迟很大。

