**Synchronzied可以应用在普通方法，静态方法，以及代码块中。**

1. 当应用在代码块中的时候，在代码块的开始处会有monitorenter标志加锁成功，在代码块的结束部分，会有monitorexit标志解锁成功。
2. 当该关键字应用于方法时，编译为字节码之后，会被翻译为和普通方法一样的invokevirtual和areturn指令，但是该方法的acc_flag字段会被设置为1，表示同步方法。

在JDK1.6之前，Synchronzied的实现基于操作系统的互斥锁实现，由于其用户态到内核态频繁的切换，消耗系统的性能，属于重量级锁。

在现在的JDK中，加入了偏向锁，轻量级锁，重量级锁，以及自旋锁（属于锁的优化）。

**什么是锁的降级，升级/膨胀？**
```
锁的降级在java的隐式锁中，表现为从重量级锁-》轻量级锁-》偏向锁。在JDK内部，会根据竞争情况自动对锁进行降级实现锁的优化。
在显式锁中，锁的降级表现为写锁-》读锁，具体为当同一线程持有当前对象的写锁时，如果有读请求，则可尝试让其进行写模式，然后获取读锁，释放写锁，实现锁的降级。

锁的升级在java的隐式锁中，表现为从偏向锁-》轻量级锁-》重量级锁。关于锁的升级后面详细说明。
在显式锁中，锁的升级表现为读锁-》写锁。
```

1. 当不存在锁的竞争的时候，如果开启了偏向锁的设置（-XX:UserBiasedLocking），则JVM会利用CAS操作循环设置对象头的Mark Word部分的ID字段设置为当前线程的ID，以表示当前线程获取了锁。
2. 如果出现锁的竞争，即另外一个线程尝试获取被为获取偏向锁的对象锁时，JVM会撤销偏向锁，并且切换到轻量级锁实现。轻量级锁的是实现是使用CAS方式操作Mark Word来试图获取，如果获取成功则转为轻量级锁，否则，进一步升级为重量级锁。

**如何判断从偏向锁转为轻量级锁以及到重量锁？**

下一次有线程尝试获取锁的时候，首先检查这个对象头的MarkWord是不是储存着这个线程的ID。如果是，那么直接进去而不需要任何别的操作。如果不是，那么分为两种情况。1，对象的偏向锁标志位为0（当前不是偏向锁），说明发生了竞争，已经膨胀为轻量级锁，这时使用CAS操作尝试获得锁（这个操作具体是轻量级锁的获得锁的过程下面讲）。2，偏向锁标志位为1，说明还是偏向锁不过请求的线程不是原来那个了。这时只需要使用CAS尝试把对象头偏向锁从原来那个线程指向目前求锁的线程。

这个CAS失败了呢？首先必须明确这个CAS为什么会失败，也就是说发生了竞争，有别的线程和它抢锁并且抢赢了，那么这个情况下，它就会要求撤销偏向锁（因为发生了竞争）。接着它首先暂停拥有偏向锁的线程，检查这个线程是否是个活动线程，如果不是，那么好，你拿了锁但是没在干事，锁还记录着你，那么直接把对象头设置为无锁状态重新来过。如果还是活动线程，先遍历栈帧里面的锁记录，让这个偏向锁变为无锁状态，然后恢复线程。


