#### 一、类加载过程
首先类加载过程被分为加载，链接，初始化。
首先是加载阶段，它是将java的字节码数据从不同的数据源读取到JVM中，并映射为JVM中认可的数据结构（Class对象）。

接着是链接状态，主要细分为下面三个过程：
1. 验证：JVM需要检验字节信息是否符合java虚拟机规范，否则被认为是VerifyError，这样就防止了恶意信息或者不合规范的信息危害JVM的运行，验证阶段有可能
触发更多的class的加载。
2. 准备：创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不
会去执行更进一步的 JVM 指令。
3. 解析：在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在Java 虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。

初始化阶段：
这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，
父类型的初始化逻辑优先于当前类型的逻辑。

#### 二、双亲委派模型
简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委
派模型的目的是避免重复加载 Java 类型。

在Oracle的JDK中主要有下面三种类型的类加载器：
1. 启动类加载器（Bootstrap Class-Loader），加载 jre/lib 下面的 jar 文件，如 rt.jar。它是个超级公民，即使是在开启了 Security Manager 的时候，JDK 仍赋予了它加载的程序AllPermission。
2. 扩展类加载器（Extension or Ext Class-Loader），负责加载我们放到 jre/lib/ext/ 目录下面的 jar 包，这就是所谓的 extension 机制。该目录也可以通过设置 “java.ext.dirs”来覆盖。
3. 应用类加载器（Application or App Class-Loader），就是加载我们最熟悉的 classpath 的内容。这里有一个容易混淆的概念，系统（System）类加载器，通常来说，其默认就是 JDK内建的应用类加载器，但是它同样是可能修改的，比如：
```
java -Djava.system.class.loader=com.yourcorp.YourClassLoader HelloWorld
```

双亲委派模型如下图所示：
![双亲委派模型](https://github.com/ljcan/Review/blob/master/Java/pictures/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png)

**双亲委派模型的三个基本特征**
1. 双亲委派模型：但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类
型，是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider/ServiceLoader机制，用
户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。 例如，
Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就
不会用双亲委派模型去加载，而是利用所谓的上下文加载器。
2. 可见性：子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，不然，因为缺
少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。
3. 单一性：由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不
会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多
次，因为互相并不可见。

**在JVM中，一个类的唯一性是由类本身及加载该类的类加载器决定的，因此即使完全相同的class文件，使用不同的类加载器加载，也会是互相独立的类，即类是互相隔离。**

在JDK9中：
扩展类加载器被重命名为平台类加载器（Platform Class-Loader），而且 extension 机制则
被移除。也就意味着，如果我们指定 java.ext.dirs 环境变量，或者 lib/ext 目录存在，JVM
将直接返回错误！建议解决办法就是将其放入 classpath 里。

