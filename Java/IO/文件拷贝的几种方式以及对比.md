java中的文件拷贝主要有三种方式来实现。

#### 一、使用输入输出流
可以使用java.io包下的FileInputStream从源文件中读取然后为目标文件构建一个ileOutputStream输出流来实现。
具体代码实现如下：
```
public static void copyFileByStream(File source, File dest) throws
IOException {
try (InputStream is = new FileInputStream(source);
OutputStream os = new FileOutputStream(dest);){
byte[] buffer = new byte[1024];
int length;
while ((length = is.read(buffer)) > 0) {
os.write(buffer, 0, length);
}
}
}
```

当我们使用输入输出流进行读写时，实际上是进行了多次上下文切换，比如应用读取数据时，先
在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。

![输入输出流拷贝](https://github.com/ljcan/Review/blob/master/Java/pictures/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E6%8B%B7%E8%B4%9D.png)

#### 二、TransferTo与TransferFrom实现
 java.nio 类库提供的 transferTo 或 transferFrom 方法实现。
 ```
 public static void copyFileByChannel(File source, File dest) throws
IOException {
try (FileChannel sourceChannel = new FileInputStream(source)
.getChannel();
FileChannel targetChannel = new FileOutputStream(dest).getChannel
();){
for (long count = sourceChannel.size() ;count>0 ;) {
long transferred = sourceChannel.transferTo(
sourceChannel.position(), count, targetChannel); 
sourceChannel...
count -= transferred;
}
}
}
 ```
 
 而基于 NIO transferTo 的实现方式，在 Linux 和 Unix 上，则会使用到零拷贝技术，数据传输
并不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性
能。注意，transferTo 不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后
进行 Socket 发送，同样可以享受这种机制带来的性能和扩展性提高。
![零拷贝](https://github.com/ljcan/Review/blob/master/Java/pictures/transferTo%E6%8B%B7%E8%B4%9D.png)
 
 #### 三、使用传统的Files.copy实现
 其原理是使用了用户态空间的拷贝。
 
 
 **对于 Copy 的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO
transferTo/From 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝
和上下文切换。**
 
