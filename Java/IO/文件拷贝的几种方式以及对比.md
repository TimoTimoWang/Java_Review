java中的文件拷贝主要有三种方式来实现。

#### 一、使用输入输出流
可以使用java.io包下的FileInputStream从源文件中读取然后为目标文件构建一个ileOutputStream输出流来实现。
具体代码实现如下：
```
public static void copyFileByStream(File source, File dest) throws
IOException {
try (InputStream is = new FileInputStream(source);
OutputStream os = new FileOutputStream(dest);){
byte[] buffer = new byte[1024];
int length;
while ((length = is.read(buffer)) > 0) {
os.write(buffer, 0, length);
}
}
}
```

当我们使用输入输出流进行读写时，实际上是进行了多次上下文切换，比如应用读取数据时，先
在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。

![输入输出流拷贝](https://github.com/ljcan/Review/blob/master/Java/pictures/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E6%8B%B7%E8%B4%9D.png)

#### 二、TransferTo与TransferFrom实现
 java.nio 类库提供的 transferTo 或 transferFrom 方法实现。
 ```
 public static void copyFileByChannel(File source, File dest) throws
IOException {
try (FileChannel sourceChannel = new FileInputStream(source)
.getChannel();
FileChannel targetChannel = new FileOutputStream(dest).getChannel
();){
for (long count = sourceChannel.size() ;count>0 ;) {
long transferred = sourceChannel.transferTo(
sourceChannel.position(), count, targetChannel); 
sourceChannel...
count -= transferred;
}
}
}
 ```
 
 而基于 NIO transferTo 的实现方式，在 Linux 和 Unix 上，则会使用到零拷贝技术，数据传输
并不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性
能。注意，transferTo 不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后
进行 Socket 发送，同样可以享受这种机制带来的性能和扩展性提高。
![零拷贝](https://github.com/ljcan/Review/blob/master/Java/pictures/transferTo%E6%8B%B7%E8%B4%9D.png)
 
 #### 三、使用传统的Files.copy实现
 其原理是使用了用户态空间的拷贝。
 
 
 **对于 Copy 的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO
transferTo/From 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝
和上下文切换。**

#### Buffer的使用
**Buffer 有几个基本属性：**
1. capcity，它反映这个 Buffer 到底有多大，也就是数组的长度。
2. position，要操作的数据起始位置。
3. limit，相当于操作的限额。在读取或者写入时，limit 的意义很明显是不一样的。比如，读取
操作时，很可能将 limit 设置到所容纳数据的上限；而在写入时，则会设置容量或容量以下的
可写限度。
4. mark，记录上一次 postion 的位置，默认是 0，算是一个便利性的考虑，往往不是必须的

**Buffer 的基本操作：**
1. 我们创建了一个 ByteBuffer，准备放入数据，capcity 当然就是缓冲区大小，而 position 就
是 0，limit 默认就是 capcity 的大小。
2. 当我们写入几个字节的数据时，position 就会跟着水涨船高，但是它不可能超过 limit 的大
小。
3. 如果我们想把前面写入的数据读出来，需要调用 flip 方法，将 position 设置为 0，limit 设
置为以前的 position 那里。
4. 如果还想从头再读一遍，可以调用 rewind，让 limit 不变，position 再次设置为 0。

 
