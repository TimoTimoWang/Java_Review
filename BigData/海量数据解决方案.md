**1.有40亿个IPV4的IP地址，请对这些IP地址进行排序**

**难点：** 如果使用简单的排序算法，比如快排，大约需要4GB内存，内存占用太大。

**思路：使用bitmap**

IPV4的IP地址总共约42亿个。因此申请一个长度为2^32的bit数组，数组中的每个元素只占1bit大小，那么该数组占用内存大约128兆。
然后从磁盘读取IP数据，并且逐个将其转换为一个整数，并且将对应数组的该整数下标位置置为1。最后依次遍历这个数组，将数组为1
的位置的下标索引读取出来并且转换为IP地址，这样就完成了IP地址的排序


**2.有20亿个全是32位大整数的文件，在其中找出出现次数最多的数，要求内存限制为2GB**

**难点：** 如果使用map的方式，对其进行词频统计，那么内存占用太大，将会远远超过题目要求的2GB限制。

**思路：hash函数**

利用hash函数的性质，key相同会有相同的hash值，因此可以将20亿个文件使用hash函数分流为多个文件，比如16个文件，然后针对内存的
情况可以再进行分流，接着统计出每个小文件中出现次数最多的整数，向上汇总，最后得出出现次数最多的整数。


**3. 32位无符号整数的范围为0~4294967295。现在有一个正好包含40亿个无符号整数的文件，因此这个文件中必然有没出现的数字，给10M内存，
找出一个没有出现的数字即可，如何找？**

**难点：** 如果采用依次查找的方式时间复杂度太高，如果进行排序的话内存放不下。

**思路：hash函数+bitmap**

使用hash函数从0~2^32区间划分为64个区间，总共有40亿个数，那么总会有区间不满2^32/64个数字，然后依次遍历这些区间的整数个数，
拿出一个不满2^32/64个整数的区间，遍历这个区间的整数，使用bitmap标记出现的数字，那么可以找出一个没有出现的整数。

**4. 某搜索公司的每天的搜索数据是海量，假设有百亿的数据，设计一种求出每天最热的100词的可行办法。**

**思路：hash函数+最小堆**

使用mapreduce的思路，将百亿数据利用hash函数分流到多台机器上，然后将将每台机器上的数据分为多个小文件，对每个小文件使用最小堆求TOP100
数据，然后合并这个机器上的所有文件，使用最小堆求出这个机器上的TOP100数据，最后合并所有机器上的TOP100数据利用最小堆求出总体的TOP100数据即可。

**潜在问题：添加或者删除机器都会导致海量数据的迁移，怎么解决？使用分布式一致性Hash算法即可。**
